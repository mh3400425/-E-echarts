.版本 2
.支持库 commobj
.支持库 spec

.程序集 eCharts_JSON类, , 公开, 源码作者：qqq123123，原贴：http://bbs.eyuyan.com/read.php?tid=400198，本人（lsy9202）添加少许改造。
.程序集变量 DataName, 文本型, , , 根节点名称
.程序集变量 Object, 对象, , , Js对象

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用

CoInitialize (0)
DataName ＝ “Json”
Object.创建 (“MSScriptControl.ScriptControl”, )  ' //创建Com对象
Object.写属性 (“Language”, “JavaScript”)  ' //设定语言
Object.数值方法 (“AddCode”, #Js3)  ' //加载代码
Object.数值方法 (“Eval”, “var ” ＋ DataName ＋ “={}”)  ' //定义一个空对象

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用

Object.清除 ()
CoUninitialize ()

.子程序 解析, 逻辑型, 公开, 解析Json文本
.参数 参_Json文本, 文本型, 可空
.参数 参_编码转换, 逻辑型, 可空, 可空，默认不进行编码转换
.局部变量 Str, 文本型

.如果真 (参_Json文本 ＝ “”)
    参_Json文本 ＝ “{}”
.如果真结束
.如果真 (参_编码转换 ＝ 真)
    参_Json文本 ＝ U2A (参_Json文本)
.如果真结束
Object.数值方法 (“Eval”, “var ” ＋ DataName ＋ “=null”)  ' //初始化
Object.数值方法 (“AddCode”, “var ” ＋ DataName ＋ “=eval(” ＋ 参_Json文本 ＋ “)”)  ' //使用eval()方法，但是该方法存在性能和安全方面的问题！

返回 (Object.逻辑方法 (“Eval”, “null !=” ＋ DataName))

.子程序 U2A, 文本型, , 将usc2转变成ansi  如 %u0031%u0032%u0033 转换后为 123 失败返回空文本
.参数 欲转换的文本, 文本型, , \u %u \u25 等3种格式,如果是其它格式,请先用子文本替换成这三种的任意一种才能正常转换
.局部变量 Obj, 对象
.局部变量 Str, 文本型
.局部变量 Ret, 文本型

Str ＝ 子文本替换 (欲转换的文本, #换行符, “{$}”, , , 真)
.如果真 (取字节集左边 (到字节集 (取文本左边 (Str, 10)), 1) ＝ { 13 })
    Str ＝ 到文本 (子字节集替换 (到字节集 (Str), { 13 }, {  }, , 1))
.如果真结束
.判断开始 (寻找文本 (Str, “\u”, , 假) ≠ -1)
    Str ＝ 子文本替换 (Str, “\u”, “%u”, , , 真)
.判断 (寻找文本 (Str, “\u25”, , 假) ≠ -1)
    Str ＝ 子文本替换 (Str, “\u25”, “%u”, , , 真)
.默认

.判断结束
Str ＝ 子文本替换 (Str, “'”, “’”, , , 真)
CoInitialize (0)
Obj.创建 (“ScriptControl”, )
Obj.写属性 (“Language”, “JScript”)
Obj.数值方法 (“ExecuteStatement”, “function xx(){var x='” ＋ Str ＋ “';return unescape(x);}”)
Ret ＝ Obj.文本方法 (“Run”, “xx”)
Ret ＝ 选择 (取文本长度 (Ret) ＝ 0, UnEscape (Str), Ret)
Obj.清除 ()
CoUninitialize ()
Ret ＝ 子文本替换 (Ret, “’”, “'”, , , 真)
返回 (子文本替换 (Ret, “{$}”, #换行符, , , 真))

.子程序 UnEscape, 文本型
.参数 欲解码文本, 文本型
.局部变量 i
.局部变量 l
.局部变量 c, 文本型
.局部变量 s, 文本型
.局部变量 p, 文本型

l ＝ 取文本长度 (欲解码文本)
.变量循环首 (1, l, 1, i)
    c ＝ 取文本中间 (欲解码文本, i, 1)
    .如果真 (c ＝ “%”)
        .如果 (取文本中间 (欲解码文本, i ＋ 1, 1) ＝ “u” 且 i ≤ l － 5)
            s ＝ 取文本中间 (欲解码文本, i ＋ 2, 4)
            .如果真 (到整数 (s) ≠ 0)
                c ＝ 到文本 (Unicode2A (到字节集 (进制转换 (s, 16, 10))))
                i ＝ i ＋ 2
            .如果真结束

        .否则
            .如果真 (i ≤ l － 2)
                s ＝ 取文本中间 (欲解码文本, i ＋ 1, 2)
                c ＝ 到文本 (Unicode2A (到字节集 (进制转换 (s, 16, 10))))
                i ＝ i ＋ 2
            .如果真结束

        .如果结束
        p ＝ p ＋ c
    .如果真结束

.变量循环尾 ()
返回 (p)

.子程序 Unicode2A, 文本型, , 带BOM头信息编码转换。
.参数 欲转换的文本, 字节集
.局部变量 Obj, 对象
.局部变量 Text, 文本型
.局部变量 Val, 变体型
.局部变量 Type, 文本型

CoInitialize (0)
Val.赋值 (欲转换的文本, )
.如果真 (Obj.创建 (“Adodb.Stream”, ) ＝ 假)
    返回 (“”)
.如果真结束
Obj.写属性 (“Type”, 1)
Obj.写属性 (“Mode”, 3)
Obj.方法 (“Open”, )
Obj.方法 (“Write”, Val)
Obj.写属性 (“Position”, 0)
Obj.写属性 (“Type”, 2)
Obj.写属性 (“Charset”, “unicode”)
Text ＝ Obj.文本方法 (“ReadText”, )
Obj.方法 (“Close”, )
CoUninitialize ()
返回 (Text)

.子程序 取代码, 文本型, 公开, 获取Json文本
.参数 参_是否格式化, 逻辑型, 可空, 可空，为假。真，则返回格式化后的Js文本。
.局部变量 Str, 文本型, , , 返回文本
.局部变量 Js, 脚本类

Str ＝ Object.文本方法 (“Eval”, “JSON.stringify(” ＋ DataName ＋ “)”)
.如果真 (参_是否格式化)
    Str ＝ Js.格式化 (Str)
.如果真结束
' Str ＝ 选择 (参_是否格式化 ＝ 真, Js.格式化 (Str, , ), Str)
' 返回 (Deserialize (Str))
返回 (Str)

.子程序 清空, 逻辑型, 公开, 清空Js对象

返回 (Object.逻辑方法 (“Eval”, “var ” ＋ DataName ＋ “={}”))  ' //定义一个空对象

.子程序 取成员数, 整数型, , 取成员数。（lsy9202注：暂时禁用此方法，不太明白其作用，取数组和对象成员数量都不对）
.参数 参_节点路径, 文本型, 可空, 可空，为根目录。支持a.b.c[0]或者[0].a.b等路径，包括数字键名或者含有特殊符号等键名。
.局部变量 Path, 文本型, , , 节点路径

.如果 (参_节点路径 ≠ “”)
    Path ＝ DataName ＋ “.” ＋ 参_节点路径
.否则
    Path ＝ DataName
.如果结束
返回 (Object.数值方法 (“Eval”, “get__count(” ＋ PathFilter (Path) ＋ “)”))

.子程序 取类型, 整数型, 公开, 取类型 2数 4 对象 5 数组 6 文本
.参数 参_节点路径, 文本型, 可空, 可空，为根目录。支持a.b.c[0]或者[0].a.b等路径，包括数字键名或者含有特殊符号等键名。
.局部变量 Type, 文本型, , , 类型
.局部变量 Path, 文本型, , , 节点路径

.如果 (参_节点路径 ≠ “”)
    Path ＝ DataName ＋ “.” ＋ 参_节点路径
.否则
    Path ＝ DataName
.如果结束
Type ＝ Object.文本方法 (“Eval”, “typeof (” ＋ PathFilter (Path) ＋ “)”)
.如果真 (Type ＝ “object”)
    .判断开始 (Object.逻辑方法 (“Eval”, “!” ＋ PathFilter (Path) ＋ “.map”))  ' //数组
        返回 (4)
    .默认
        返回 (5)
    .判断结束

.如果真结束
.如果真 (Type ＝ “string”)
    返回 (6)
.如果真结束
.如果真 (Type ＝ “number”)
    返回 (2)
.如果真结束
返回 (-1)

.子程序 取键名, 文本型, 公开, 用于取不确定键名名称的情况
.参数 参_节点路径, 文本型, 可空, 可空，为根目录。支持a.b.c[0]或者[0].a.b等路径，包括数字键名或者含有特殊符号等键名。
.参数 参_对象索引, 整数型, , 欲取键名的索引。注意：Js数组成员下标从0开始。
.局部变量 Arr, 文本型, , , 用于存储Obj对象获取到键名
.局部变量 Path, 文本型, , , 节点路径
.局部变量 Rec, 文本型, , "0", 分割后的键名数组
.局部变量 Index, 整数型, , , 对象索引

.如果 (参_节点路径 ≠ “”)
    Path ＝ DataName ＋ “.” ＋ 参_节点路径
.否则
    Path ＝ DataName
.如果结束
Arr ＝ Object.文本方法 (“Eval”, “var keys=''; for (var key in ” ＋ PathFilter (Path) ＋ “) if(” ＋ PathFilter (Path) ＋ “.hasOwnProperty(key)){keys = keys + key + ','; }”)
Object.通用方法 (“Eval”, “Ary=null”)
Rec ＝ 分割文本 (Arr, “,”, )
Index ＝ 参_对象索引 ＋ 1  ' //易语言数组是从1开始，而Js是从0开始
.如果真 (取数组成员数 (Rec) ≥ Index)
    .判断开始 (参_节点路径 ＝ “”)
        返回 (参_节点路径 ＋ Rec [Index])
    .默认
        返回 (参_节点路径 ＋ “.” ＋ Rec [Index])
    .判断结束

.如果真结束
返回 (“”)

.子程序 取所有键名, , 公开, 取所有键名
.参数 参_节点路径, 文本型, 可空, 可空，为根目录。支持a.b.c[0]或者[0].a.b等路径，包括数字键名或者含有特殊符号等键名。
.参数 参_接收变量, 文本型, 参考 数组, 数组类型变量，用于接收所有键名。
.局部变量 Arr, 文本型, , , 用于存储Obj对象获取到键名
.局部变量 Path, 文本型, , , 节点路径

.如果 (参_节点路径 ≠ “”)
    Path ＝ DataName ＋ “.” ＋ 参_节点路径
.否则
    Path ＝ DataName
.如果结束
Arr ＝ Object.文本方法 (“Eval”, “var keys=''; for (var key in ” ＋ PathFilter (Path) ＋ “) if(” ＋ PathFilter (Path) ＋ “.hasOwnProperty(key)){keys = keys + key + ','; }”)
Object.通用方法 (“Eval”, “Ary=null”)
参_接收变量 ＝ 分割文本 (Arr, “,”, )

.子程序 取所有值, 整数型, 公开
.参数 参_节点路径, 文本型, 可空
.参数 参_接收变量, 文本型, 参考 可空 数组
.局部变量 Str, 文本型
.局部变量 Path, 文本型, , , 节点路径

.如果 (参_节点路径 ≠ “”)
    Path ＝ DataName ＋ “.” ＋ 参_节点路径
.否则
    Path ＝ DataName
.如果结束
Str ＝ Object.文本方法 (“Eval”, “var temp='';for(var key in ” ＋ PathFilter (Path) ＋ “){temp=temp+” ＋ PathFilter (Path) ＋ “[key]+'/n'}”)
Str ＝ 子文本替换 (Str, “function(filter){return JSON.parse(this,filter);}/n”, , , , 真)
Str ＝ 子文本替换 (Str, “function(filter){return JSON.stringify(this,filter);}/n”, , , , 真)
参_接收变量 ＝ 分割文本 (Str, “/n”, )
返回 (取数组成员数 (参_接收变量))

.子程序 路径是否为空, 逻辑型, 公开, 是否为空
.参数 参_节点路径, 文本型, 可空, 可空，为根目录。支持a.b.c[0]或者[0].a.b等路径，包括数字键名或者含有特殊符号等键名。
.局部变量 Path, 文本型, , , 节点路径

.如果 (参_节点路径 ≠ “”)
    Path ＝ DataName ＋ “.” ＋ 参_节点路径
.否则
    Path ＝ DataName
.如果结束
返回 (Object.逻辑方法 (“Eval”, PathFilter (Path) ＋ “==null”))

.子程序 是否存在, 逻辑型, 公开, 是否存在
.参数 参_节点路径, 文本型, , 可空，为根目录。支持a.b.c[0]或者[0].a.b等路径，包括数字键名或者含有特殊符号等键名。
.局部变量 Path, 文本型, , , 节点路径

.如果 (参_节点路径 ≠ “”)
    Path ＝ DataName ＋ “.” ＋ 参_节点路径
.否则
    Path ＝ DataName
.如果结束
返回 (Object.逻辑方法 (“Eval”, PathFilter (Path) ＋ “!=null”))

.子程序 取通用型, 文本型, 公开, 返回对象文本，自行转换为各种数据类型 到整数（） 到小数（）···
.参数 参_节点路径, 文本型, 可空, 可空，为根目录。支持a.b.c[0]或者[0].a.b等路径，包括数字键名或者含有特殊符号等键名。
.局部变量 Path, 文本型, , , 节点路径

.如果 (参_节点路径 ≠ “”)
    .如果 (取文本左边 (参_节点路径, 1) ＝ “[”)
        Path ＝ DataName ＋ 参_节点路径
    .否则
        Path ＝ DataName ＋ “.” ＋ 参_节点路径
    .如果结束

.否则
    Path ＝ DataName
.如果结束
返回 (Deserialize (Object.文本方法 (“Eval”, “JSON.stringify(” ＋ PathFilter (Path) ＋ “)”)))

.子程序 取文本, 文本型, 公开
.参数 参_节点路径, 文本型, 可空, 可空，为根目录。支持a.b.c[0]或者[0].a.b等路径，包括数字键名或者含有特殊符号等键名。
.局部变量 返回值, 文本型

返回值 ＝ 取通用型 (参_节点路径)
.如果真 (取文本左边 (返回值, 1) ＝ #引号)
    返回值 ＝ 取文本右边 (返回值, 取文本长度 (返回值) － 1)
.如果真结束
.如果真 (取文本右边 (返回值, 1) ＝ #引号)
    返回值 ＝ 取文本左边 (返回值, 取文本长度 (返回值) － 1)
.如果真结束
返回 (返回值)

.子程序 取整数, 整数型, 公开
.参数 参_节点路径, 文本型, 可空, 可空，为根目录。支持a.b.c[0]或者[0].a.b等路径，包括数字键名或者含有特殊符号等键名。

返回 (到整数 (取通用型 (参_节点路径)))

.子程序 取长整数, 长整数型, 公开
.参数 参_节点路径, 文本型, 可空, 可空，为根目录。支持a.b.c[0]或者[0].a.b等路径，包括数字键名或者含有特殊符号等键名。

返回 (到长整数 (取通用型 (参_节点路径)))

.子程序 取逻辑, 逻辑型, 公开
.参数 参_节点路径, 文本型, 可空, 可空，为根目录。支持a.b.c[0]或者[0].a.b等路径，包括数字键名或者含有特殊符号等键名。

返回 (选择 (取通用型 (参_节点路径) ＝ “true”, 真, 假))

.子程序 取双精度小数, 双精度小数型, 公开
.参数 参_节点路径, 文本型, 可空, 可空，为根目录。支持a.b.c[0]或者[0].a.b等路径，包括数字键名或者含有特殊符号等键名。

返回 (到数值 (取通用型 (参_节点路径)))

.子程序 取小数, 小数型, 公开
.参数 参_节点路径, 文本型, 可空, 可空，为根目录。支持a.b.c[0]或者[0].a.b等路径，包括数字键名或者含有特殊符号等键名。

返回 (到数值 (取通用型 (参_节点路径)))

.子程序 取对象, 文本型, 公开
.参数 参_节点路径, 文本型, 可空, 可空，为根目录。支持a.b.c[0]或者[0].a.b等路径，包括数字键名或者含有特殊符号等键名。

返回 (取通用型 (参_节点路径))

.子程序 PathFilter, 文本型, , 获取处理后的节点路径，对节点路径中存在数字键值等特殊字符的情况，进行特殊处理
.参数 参_节点路径, 文本型, , 可空，为根目录。支持a.b.c[0]或者[0].a.b等路径，包括数字键名或者含有特殊符号等键名。
.局部变量 Path, 文本型, , , 节点路径
.局部变量 Arr, 文本型, , "0", 用于记录分割后的节点路径
.局部变量 i, 整数型, , , 计次
.局部变量 Index, 文本型, , , 索引。如果是数组类型的话，进行特殊处理后（字符转义），仍然要还原数组索引。

Path ＝ 子文本替换 (参_节点路径, “-”, “”, , , 真)  ' //这里可以考虑直接替换到节点路径里不符合条件的特殊符号，因为JS本身就不识别。比如“-”、“.”等。提高容错能力！
Arr ＝ 分割文本 (删首尾空 (参_节点路径), “.”, )
.计次循环首 (取数组成员数 (Arr), i)
    .判断开始 (IsArr (Arr [i]) ＝ 真)  ' //数组
        .如果真 (IsVarChar (GetLeftChar (Arr [i], Index)) ＝ 真)  ' //特殊字符的键名！如果是数组的话，替换后还必须带上原来的索引！
            Path ＝ 子文本替换 (Path, “.” ＋ Arr [i], “['” ＋ GetLeftChar (Arr [i]) ＋ “']” ＋ Index, , , 真)  ' //进行相应的格式替换！
        .如果真结束

    .默认
        ' //非数组
        .如果真 (IsVarChar (GetLeftChar (Arr [i], )) ＝ 真)  ' //特殊字符的键名
            Path ＝ 子文本替换 (Path, “.” ＋ Arr [i], “['” ＋ GetLeftChar (Arr [i]) ＋ “']”, , , 真)  ' //进行相应的格式替换！
        .如果真结束

    .判断结束

.计次循环尾 ()
返回 (Path)

.子程序 IsArr, 逻辑型, , 是否为数组形式
.参数 参_文本, 文本型

.判断开始 (寻找文本 (参_文本, “[”, , 假) ＝ -1)
    返回 (假)
.默认
    返回 (真)
.判断结束


.子程序 GetLeftChar, 文本型, , 分为数组和非数组两种类型。如果是数组的话，记得返回数组索引！
.参数 参_文本, 文本型
.参数 参_数组索引, 文本型, 参考 可空
.局部变量 pos, 整数型
.局部变量 ret, 文本型

pos ＝ 寻找文本 (参_文本, “[”, , 假)
.判断开始 (pos ＝ -1)
    返回 (参_文本)
.默认
    ret ＝ 取文本左边 (参_文本, pos － 1)
    参_数组索引 ＝ 取文本右边 (参_文本, 取文本长度 (参_文本) － pos ＋ 1)
    返回 (ret)
.判断结束


.子程序 IsVarChar, 逻辑型, , 处理一下空格等特殊字符
.参数 参_文本, 文本型
.局部变量 Arrs, 文本型, , "0"
.局部变量 i, 整数型

.如果真 (寻找文本 (参_文本, “ ”, , 假) ≠ -1)  ' //空格
    返回 (真)
.如果真结束
.如果真 (寻找文本 (参_文本, “:”, , 假) ≠ -1)  ' //冒号
    返回 (真)
.如果真结束
.如果真 (寻找文本 (参_文本, “,”, , 假) ≠ -1)  ' //逗号
    返回 (真)
.如果真结束
.如果真 (IsNum (参_文本) ＝ 真)  ' //数字键名
    返回 (真)
.如果真结束
Arrs ＝ 分割文本 (#JsKeysWords, #换行符, )  ' //排除Js关键字
.计次循环首 (取数组成员数 (Arrs), i)
    .如果真 (参_文本 ＝ Arrs [i])
        返回 (真)
    .如果真结束

.计次循环尾 ()
Arrs ＝ 分割文本 (#JsReservedWords, #换行符, )  ' //排除Js保留字
.计次循环首 (取数组成员数 (Arrs), i)
    .如果真 (参_文本 ＝ Arrs [i])
        返回 (真)
    .如果真结束

.计次循环尾 ()
返回 (假)

.子程序 IsNum, 逻辑型, , 中间不能有空格,用正则表达式来验证字符串是否为数字字符串。
.参数 参_文本, 文本型
.局部变量 i, 整数型
.局部变量 Len, 整数型
.局部变量 Asc, 整数型

Len ＝ 取文本长度 (参_文本)
.如果真 (Len ＝ 0)
    返回 (假)
.如果真结束
.计次循环首 (Len, i)
    Asc ＝ 取代码 (参_文本, i)
    .判断开始 (Asc ＜ 48)  ' a=97
        返回 (假)
    .判断 (Asc ＞ 57)  ' z=122
        返回 (假)
    .默认

    .判断结束

.计次循环尾 ()
返回 (真)

.子程序 Serialize, 文本型, , 元字符序列化
.参数 参_文本, 文本型, 可空
.参数 参_是否区分大小写, 逻辑型, 可空
.局部变量 i, 整数型
.局部变量 OldObj, 文本型, , "0"
.局部变量 NewObj, 文本型, , "0"

OldObj ＝ { “\”, “?”, “*”, “+”, “[”, “]”, “(”, “)”, “.”, “|”, “^”, “$”, “'” }
NewObj ＝ { “\\”, “\?”, “\*”, “\+”, “\[”, “\]”, “\(”, “\)”, “\.”, “\|”, “\^”, “\$ ”, “\'” }
.计次循环首 (取数组成员数 (OldObj), i)
    参_文本 ＝ 子文本替换 (参_文本, OldObj [i], NewObj [i], , , 参_是否区分大小写)
.计次循环尾 ()
参_文本 ＝ 子文本替换 (参_文本, #换行符, “\n”, , , 真)
返回 (参_文本)


.子程序 Deserialize, 文本型, , 元字符反序列化
.参数 参_文本, 文本型, 可空
.参数 参_是否区分大小写, 逻辑型, 可空
.局部变量 obj, 快速文本对象

参_文本 ＝ 子文本替换 (参_文本, “\\”, “\”, , , 真)
返回 (参_文本)

.子程序 置通用型, , 公开, 赋值
.参数 参_节点路径, 文本型, , 可空，为根目录。支持a.b.c[0]或者[0].a.b等路径，包括数字键名或者含有特殊符号等键名。
.参数 参_新值, 文本型, , 欲赋值内容
.参数 参_数据类型, 整数型, , 可空，默认为文本型。备注：0 文本型 1 逻辑型 2 Null 3 对象 4 整数型
.局部变量 Arr, 文本型, , "0", 用于分割节点路径，所得到的文本数组
.局部变量 Path, 文本型, , , 节点路径
.局部变量 path1, 文本型, , "0", 节点路径1
.局部变量 i, 整数型, , , 计次1
.局部变量 j, 整数型, , , 计次2
.局部变量 Key, 文本型, , , 内部自动处理键值类型。比如：'你好'

' //判断一下赋值的内容是不是对象。形如{"作者":"胡连生"}，则不需要加上''；非对象类型，则需要加上''。例如：'欢迎使用'
' --------------------------------------------------------------------------------------------------------
.判断开始 (参_数据类型 ＝ #Type_String)  ' //文本型
    Key ＝ “'” ＋ Serialize (参_新值) ＋ “'”  ' //元字符转义
.判断 (参_数据类型 ＝ #Type_Bool)  ' //逻辑型
    Key ＝ 选择 (参_新值 ＝ “真”, “true”, “false”)
.判断 (参_数据类型 ＝ #Type_Null)  ' //逻辑型
    Key ＝ “null”
.判断 (参_数据类型 ＝ #Type_Obj)  ' //对象
    Key ＝ 参_新值
.判断 (参_数据类型 ＝ #Type_Int)  ' //整数型
    Key ＝ 参_新值
.默认
    Key ＝ “'” ＋ 参_新值 ＋ “'”
.判断结束
' --------------------------------------------------------------------------------------------------------
Arr ＝ 分割文本 (PathFilter (参_节点路径), “.”, )  ' //这里直接进行特殊键名处理！！！
.计次循环首 (取数组成员数 (Arr), i)
    .如果 (寻找文本 (Arr [i], “][”, , 假) ＝ -1)
        Path ＝ Path ＋ “.” ＋ Arr [i]  ' //获取每一级的节点路径
        .如果真 (i ＝ 取数组成员数 (Arr))  ' //最后节点
            .如果真 (取文本右边 (Arr [i], 1) ＝ “]”)  ' //判断数据类型
                AddNewArr (Path)  ' //新增空数组成员
            .如果真结束
            Voluation (Path, Key)  ' //这里直接进行Json赋值，因为之前已经进行了数据处理
        .如果真结束

        .如果真 (是否存在 (取文本右边 (Path, 取文本长度 (Path) － 1)) ＝ 假 且 Key ≠ “null”)  ' //其他位置
            .如果真 (取文本右边 (Arr [i], 1) ＝ “]”)  ' //判断数据类型，这里是数组类型
                AddNewArr (Path)  ' //新增空数组成员
            .如果真结束
            AddNewObj (Path)
        .如果真结束

    .否则
        path1 ＝ 分割文本 (Arr [i], “][”, )
        .计次循环首 (取数组成员数 (path1), j)
            .判断开始 (j ＝ 1)
                Path ＝ Path ＋ “.” ＋ path1 [1] ＋ “]”
            .判断 (j ＝ 取数组成员数 (path1))
                Path ＝ Path ＋ “[” ＋ path1 [j]
            .默认
                Path ＝ Path ＋ “[” ＋ path1 [j] ＋ “]”
            .判断结束

            .如果真 (i ＝ 取数组成员数 (Arr))  ' //最后节点
                .如果真 (取文本右边 (Arr [i], 1) ＝ “]”)  ' //判断数据类型
                    AddNewArr (Path)  ' //新增空数组成员
                .如果真结束
                Voluation (Path, Key)  ' //这里直接进行Json赋值，因为之前已经进行了数据处理
            .如果真结束

            .如果真 (是否存在 (取文本右边 (Path, 取文本长度 (Path) － 1)) ＝ 假 且 Key ≠ “null”)  ' //其他位置
                .如果真 (取文本右边 (Arr [i], 1) ＝ “]”)  ' //判断数据类型，这里是数组类型
                    AddNewArr (Path)  ' //新增空数组成员
                .如果真结束
                AddNewObj (Path)
            .如果真结束

        .计次循环尾 ()
    .如果结束

.计次循环尾 ()

.子程序 加成员, , 公开
.参数 参_节点路径, 文本型, , 可空，为根目录。支持a.b.c[0]或者[0].a.b等路径，包括数字键名或者含有特殊符号等键名。
.参数 参_索引, 整数型
.参数 参_新值, 文本型
.参数 参_类型, 整数型, 可空, 可空，默认为文本型。具体请查看常量#Type_
.局部变量 a, 文本型
.局部变量 Path, 文本型

.如果 (参_节点路径 ≠ “”)
    Path ＝ 参_节点路径 ＋ “[” ＋ 到文本 (参_索引) ＋ “]”
.否则
    Path ＝ “[” ＋ 到文本 (参_索引) ＋ “]”
.如果结束
.判断开始 (参_类型 ＝ #Type_Obj)
    置通用型 (Path, 参_新值, #Type_Obj)
.判断 (参_类型 ＝ #Type_Int)
    置通用型 (Path, 参_新值, #Type_Int)
.判断 (参_类型 ＝ #Type_Bool)
    置通用型 (Path, 参_新值, #Type_Bool)
.判断 (参_类型 ＝ #Type_Null)
    置通用型 (Path, 参_新值, #Type_Null)
.判断 (参_类型 ＝ #Type_String)
    置通用型 (Path, 参_新值, #Type_String)
.默认
    置通用型 (Path, 参_新值, #Type_String)
.判断结束


.子程序 Voluation, , , 内部直接赋值
.参数 参_节点路径, 文本型
.参数 参_新值, 文本型

.如果 (参_新值 ＝ “null”)
    Object.数值方法 (“Eval”, DataName ＋ 参_节点路径 ＋ “=null”)
.否则
    Object.方法 (“Eval”, DataName ＋ 参_节点路径 ＋ “=” ＋ 参_新值)
.如果结束


.子程序 AddNewObj, , , 新增空白对象
.参数 参_节点路径, 文本型

Object.方法 (“Eval”, DataName ＋ 参_节点路径 ＋ “=eval({})”)

.子程序 AddNewArr, , , 新增空白数组
.参数 参_节点路径, 文本型
.局部变量 Str, 文本型

Str ＝ 取文本右边 (参_节点路径, 取文本长度 (参_节点路径) － 1)
Str ＝ DataName ＋ “.” ＋ 取文本左边 (Str, 倒找文本 (Str, “[”, , 假) － 1)
Object.方法 (“Eval”, “if(” ＋ Str ＋ “ instanceof Array==false){ ” ＋ Str ＋ “=new Array() }”)

.子程序 置文本, , 公开
.参数 参_节点路径, 文本型, , 可空，为根目录。支持a.b.c[0]或者[0].a.b等路径，包括数字键名或者含有特殊符号等键名。
.参数 参_新值, 文本型, , 欲赋值内容

置通用型 (参_节点路径, 参_新值, #Type_String)

.子程序 置Null, , 公开
.参数 参_节点路径, 文本型, , 可空，为根目录。支持a.b.c[0]或者[0].a.b等路径，包括数字键名或者含有特殊符号等键名。

置通用型 (参_节点路径, “null”, #Type_Null)

.子程序 置整数, , 公开
.参数 参_节点路径, 文本型, , 可空，为根目录。支持a.b.c[0]或者[0].a.b等路径，包括数字键名或者含有特殊符号等键名。
.参数 参_新值, 整数型, , 欲赋值内容

置通用型 (参_节点路径, 到文本 (参_新值), #Type_Int)

.子程序 置长整数, , 公开
.参数 参_节点路径, 文本型, , 可空，为根目录。支持a.b.c[0]或者[0].a.b等路径，包括数字键名或者含有特殊符号等键名。
.参数 参_新值, 长整数型, , 欲赋值内容

置通用型 (参_节点路径, 到文本 (参_新值), #Type_Int)

.子程序 置逻辑型, , 公开
.参数 参_节点路径, 文本型, , 可空，为根目录。支持a.b.c[0]或者[0].a.b等路径，包括数字键名或者含有特殊符号等键名。
.参数 参_新值, 逻辑型, , 欲赋值内容

置通用型 (参_节点路径, 到文本 (参_新值), #Type_Bool)

.子程序 置对象, , 公开
.参数 参_节点路径, 文本型, , 可空，为根目录。支持a.b.c[0]或者[0].a.b等路径，包括数字键名或者含有特殊符号等键名。
.参数 参_新值, 文本型, , 欲赋值内容

置通用型 (参_节点路径, 参_新值, #Type_Obj)

.子程序 置双精度小数型, , 公开
.参数 参_节点路径, 文本型, , 可空，为根目录。支持a.b.c[0]或者[0].a.b等路径，包括数字键名或者含有特殊符号等键名。
.参数 参_新值, 双精度小数型, , 欲赋值内容

置通用型 (参_节点路径, 到文本 (参_新值), #Type_Int)

.子程序 删除, 整数型, 公开, 删除节点
.参数 参_节点路径, 文本型, , 可空，为根目录。支持a.b.c[0]或者[0].a.b等路径，包括数字键名或者含有特殊符号等键名。
.局部变量 Value, 文本型, , , 构成可能是 市区[2] 这样含数组的形式。命名规则为：前缀 + [ 索引 ]
.局部变量 Index, 整数型, , , 数组索引。比如：abc[2]，则该变量用于表示2
.局部变量 Path, 文本型, , , 节点路径
.局部变量 LeftChar, 文本型, , , 比如：abc[2]，则该变量用于表示abc

' -----------------------------------------------------------------------
' Value ＝ 取文本右边 (参_节点路径, 取文本长度 (参_节点路径) － 倒找文本 (参_节点路径, “.”, , 假))
' Index ＝ 到整数 (取文本右边 (Value, 取文本长度 (Value) － 倒找文本 (Value, “[”, , 假)))
' LeftChar ＝ 选择 (取文本右边 (Value, 1) ＝ “]”, 取文本左边 (Value, 寻找文本 (Value, “[”, , 假) － 1), Value)  ' //是否为数组
' Path ＝ 子文本替换 (参_节点路径, 取文本右边 (参_节点路径, 取文本长度 (参_节点路径) － 倒找文本 (参_节点路径, “.”, , 假)), LeftChar, , , 真)
' 调试输出 (Value, Index, LeftChar, Path)

' -----------------------------------------------------------------------
.判断开始断 (取文本右边 (参_节点路径, 1) ＝ “]”)  ' //是否为数组
    ' 返回 (Object.逻辑方法 (“Eval”, DataName ＋ “.” ＋ Filter (Path) ＋ “.splice(” ＋ 到文本 (Index) ＋ “,1)”))
.默认
    ' 返回 (Object.逻辑方法 (“Eval”, “delete ” ＋ DataName ＋ “.” ＋ Filter (Path)))
.判断结束

Index ＝ 到整数 (取文本右边 (参_节点路径, 取文本长度 (参_节点路径) － 倒找文本 (参_节点路径, “[”, , 假)))
.判断开始 (取文本右边 (参_节点路径, 1) ＝ “]”)  ' //是否为数组
    .如果真 (取文本右边 (参_节点路径, 1) ＝ “]”)
        参_节点路径 ＝ 取文本左边 (参_节点路径, 倒找文本 (参_节点路径, “[”, , 假) － 1)
        调试输出 (参_节点路径, Index)
    .如果真结束
    返回 (DelArr (参_节点路径, Index))
.默认
    返回 (DelString (参_节点路径))
.判断结束


.子程序 DelString, 整数型
.参数 Key, 文本型

返回 (Object.数值方法 (“Eval”, “delete ” ＋ DataName ＋ “.” ＋ PathFilter (Key)))

.子程序 DelArr, 整数型
.参数 Key, 文本型
.参数 Index, 整数型, 可空
.参数 Count, 整数型, 可空, 可空，默认为1

.如果真 (Count ≤ 0)
    Count ＝ 1
.如果真结束
Key ＝ PathFilter (Key)
Key ＝ 选择 (Key ＝ “”, DataName, DataName ＋ “.” ＋ Key)
Object.方法 (“Eval”, Key ＋ “.splice(” ＋ 到文本 (Index) ＋ “,” ＋ 到文本 (Count) ＋ “)”)
返回 (Object.数值方法 (“Eval”, Key ＋ “.length”))


.子程序 置新值, , 公开
.参数 key, 文本型, 可空, 支持“a.b.c”或“a[0].b”等模式混合，如果留空或者为空文本表示根键，如果是添加键，键名需要以字母或下划线开头。
.参数 value_对象, 文本型, 可空, 键值。多选一。（可使用内置‘eCharts_JSON类’生成或者照标准JSON格式写），此参数将不做处理，请注意格式书写（文本型加引号、对象加大括号"{}"、数组加中括号"[]"）
.参数 value_文本型, 文本型, 可空, 键值。多选一。
.参数 value_数值型, 双精度小数型, 可空, 键值。多选一。
.参数 value_逻辑型, 逻辑型, 可空, 键值。多选一。
.参数 value_数组, 文本型, 可空, 键值。多选一。（可使用‘创建json数组()’生成或者照格式写：[1,2,3]，文本数组成员需带引号，例如：["a","b","c"]）
.参数 value_NULL, 逻辑型, 可空, 键值。多选一。（真 = NULL）
.参数 错误信息, 文本型, 参考 可空, 返回失败时的错误信息！

.判断开始 (是否为空 (value_对象) ＝ 假)
    置通用型 (key, value_对象, #Type_Obj)
.判断 (是否为空 (value_文本型) ＝ 假)
    置通用型 (key, value_文本型, #Type_String)
.判断 (是否为空 (value_数值型) ＝ 假)
    置通用型 (key, 到文本 (value_数值型), #Type_Int)
.判断 (是否为空 (value_逻辑型) ＝ 假)
    置通用型 (key, 到文本 (value_逻辑型), #Type_Bool)
.判断 (是否为空 (value_数组) ＝ 假)
    置通用型 (key, value_数组, #Type_Obj)
.判断 (是否为空 (value_NULL) ＝ 假)
    置通用型 (key, “null”, #Type_Null)
.默认

.判断结束


.子程序 数组_取长度, 整数型, 公开, 返回数组成员数。
.参数 key, 文本型, 可空, 支持“a.b.c”或“a[0].b”等模式混合，如果留空或者为空文本表示根键。
.局部变量 对象名称, 文本型

.判断开始 (取文本长度 (key) ＞ 0)
    .判断开始 (取文本左边 (key, 1) ≠ “[”)
        对象名称 ＝ DataName ＋ “.” ＋ key
    .默认
        对象名称 ＝ DataName ＋ key
    .判断结束

.默认
    对象名称 ＝ DataName
.判断结束
返回 (Object.数值方法 (“Eval”, 对象名称 ＋ “.length”))

.子程序 数组_取出成员, 文本型, 公开, 删除并返回数组的第一个元素，如果数组已经是空值，则返回一个空值。
.参数 key, 文本型, 可空, 支持“a.b.c”或“a[0].b”等模式混合，如果留空或者为空文本表示根键。
.局部变量 对象名称, 文本型

.判断开始 (取文本长度 (key) ＞ 0)
    .判断开始 (取文本左边 (key, 1) ≠ “[”)
        对象名称 ＝ DataName ＋ “.” ＋ key
    .默认
        对象名称 ＝ DataName ＋ key
    .判断结束

.默认
    对象名称 ＝ DataName
.判断结束
返回 (Object.文本方法 (“Eval”, “JSON.stringify(” ＋ 对象名称 ＋ “.shift()” ＋ “)”))

.子程序 数组_弹出成员, 文本型, 公开, 删除并返回数组的最后一个元素，如果数组已经是空值，则返回一个空值。
.参数 key, 文本型, 可空, 支持“a.b.c”或“a[0].b”等模式混合，如果留空或者为空文本表示根键。
.局部变量 对象名称, 文本型

.判断开始 (取文本长度 (key) ＞ 0)
    .判断开始 (取文本左边 (key, 1) ≠ “[”)
        对象名称 ＝ DataName ＋ “.” ＋ key
    .默认
        对象名称 ＝ DataName ＋ key
    .判断结束

.默认
    对象名称 ＝ DataName
.判断结束
返回 (Object.文本方法 (“Eval”, “JSON.stringify(” ＋ 对象名称 ＋ “.pop()” ＋ “)”))


.子程序 数组_加入成员, 整数型, 公开, 向数组末尾添加一个或更多元素，并返回新长度。
.参数 key, 文本型, 可空, 支持“a.b.c”或“a[0].b”等模式混合，如果留空或者为空文本表示根键。
.参数 value_对象, 文本型, 可空, 成员值（多个成员之间用半角逗号隔开）。参数多选一。此参数将不做处理，请注意格式书写（文本型加引号、对象加大括号"{}"、数组加中括号"[]"）
.参数 value_文本型, 文本型, 可空, 成员值（多个成员之间用半角逗号隔开，例如：“腾讯,百度,淘宝,京东”）。参数多选一。
.参数 value_数值型, 文本型, 可空, 成员值（多个成员之间用半角逗号隔开，支持整数小数混搭，例如：“12.3,456,7.89”）。参数多选一。
.参数 value_逻辑型, 文本型, 可空, 成员值（多个成员之间用半角逗号隔开，例如：“真,假，真”或者“1,0,1”或者“true,false,true”）。参数多选一。
.参数 value_数组, 文本型, 可空, 成员值（多个成员之间用半角逗号隔开）。参数多选一。（可使用‘创建json数组()’生成或者照格式写：[1,2,3]）,此参数将不做处理，请注意格式书写（文本型加引号、对象加大括号"{}"、数组加中括号"[]"）
.局部变量 对象名称, 文本型
.局部变量 数值处理数组, 文本型, , "0"
.局部变量 最终数值, 文本型
.局部变量 计数器1, 整数型

.如果真 (取文本长度 (取文本 (key)) ＜ 2)
    置新值 (key, “[]”)
.如果真结束
.判断开始 (取文本长度 (key) ＞ 0)
    .判断开始 (取文本左边 (key, 1) ≠ “[”)
        对象名称 ＝ DataName ＋ “.” ＋ key
    .默认
        对象名称 ＝ DataName ＋ key
    .判断结束

.默认
    对象名称 ＝ DataName
.判断结束
.判断开始 (是否为空 (value_对象) ＝ 假)
    返回 (Object.数值方法 (“Eval”, 对象名称 ＋ “.push(” ＋ value_对象 ＋ “)”))
.判断 (是否为空 (value_文本型) ＝ 假)
    数值处理数组 ＝ 分割文本 (value_文本型, “,”, )
    .计次循环首 (取数组成员数 (数值处理数组), 计数器1)
        .如果 (计数器1 ＝ 1)
            最终数值 ＝ #引号 ＋ 数值处理数组 [计数器1] ＋ #引号
        .否则
            最终数值 ＝ 最终数值 ＋ “,” ＋ #引号 ＋ 数值处理数组 [计数器1] ＋ #引号
        .如果结束

    .计次循环尾 ()
    返回 (Object.数值方法 (“Eval”, 对象名称 ＋ “.push(” ＋ 最终数值 ＋ “)”))
.判断 (是否为空 (value_数值型) ＝ 假)
    返回 (Object.数值方法 (“Eval”, 对象名称 ＋ “.push(” ＋ value_数值型 ＋ “)”))
.判断 (是否为空 (value_逻辑型) ＝ 假)
    数值处理数组 ＝ 分割文本 (value_逻辑型, “,”, )
    .计次循环首 (取数组成员数 (数值处理数组), 计数器1)
        .如果 (计数器1 ＝ 1)
            .判断开始 (数值处理数组 [计数器1] ＝ “true” 或 数值处理数组 [计数器1] ＝ “1” 或 数值处理数组 [计数器1] ＝ “真”)
                最终数值 ＝ “true”
            .判断 (数值处理数组 [计数器1] ＝ “false” 或 数值处理数组 [计数器1] ＝ “0” 或 数值处理数组 [计数器1] ＝ “假”)
                最终数值 ＝ “false”
            .默认

            .判断结束

        .否则
            .判断开始 (数值处理数组 [计数器1] ＝ “true” 或 数值处理数组 [计数器1] ＝ “1” 或 数值处理数组 [计数器1] ＝ “真”)
                最终数值 ＝ 最终数值 ＋ “,” ＋ “true”
            .判断 (数值处理数组 [计数器1] ＝ “false” 或 数值处理数组 [计数器1] ＝ “0” 或 数值处理数组 [计数器1] ＝ “假”)
                最终数值 ＝ 最终数值 ＋ “,” ＋ “false”
            .默认

            .判断结束

        .如果结束

    .计次循环尾 ()
    返回 (Object.数值方法 (“Eval”, 对象名称 ＋ “.push(” ＋ 最终数值 ＋ “)”))
.判断 (是否为空 (value_数组) ＝ 假)
    返回 (Object.数值方法 (“Eval”, 对象名称 ＋ “.push(” ＋ value_数组 ＋ “)”))
.默认
    返回 (0)
.判断结束



.子程序 数组_插入成员, 整数型, 公开, 向数组开头添加一个或更多元素，并返回新长度。
.参数 key, 文本型, 可空, 支持“a.b.c”或“a[0].b”等模式混合，如果留空或者为空文本表示根键。
.参数 value_对象, 文本型, 可空, 成员值（多个成员之间用半角逗号隔开）。参数多选一。此参数将不做处理，请注意格式书写（文本型加引号、对象加大括号"{}"、数组加中括号"[]"）
.参数 value_文本型, 文本型, 可空, 成员值（多个成员之间用半角逗号隔开，例如：“腾讯,百度,淘宝,京东”）。参数多选一。
.参数 value_数值型, 文本型, 可空, 成员值（多个成员之间用半角逗号隔开，支持整数小数混搭，例如：“12.3,456,7.89”）。参数多选一。
.参数 value_逻辑型, 文本型, 可空, 成员值（多个成员之间用半角逗号隔开，例如：“真,假，真”或者“1,0,1”或者“true,false,true”）。参数多选一。
.参数 value_数组, 文本型, 可空, 成员值（多个成员之间用半角逗号隔开）。参数多选一。（可使用‘创建json数组()’生成或者照格式写：[1,2,3]）,此参数将不做处理，请注意格式书写（文本型加引号、对象加大括号"{}"、数组加中括号"[]"）
.局部变量 对象名称, 文本型
.局部变量 数值处理数组, 文本型, , "0"
.局部变量 最终数值, 文本型
.局部变量 计数器1, 整数型

.如果真 (取文本长度 (取文本 (key)) ≤ 2)
    置新值 (key, “[]”)
.如果真结束
.判断开始 (取文本长度 (key) ＞ 0)
    .判断开始 (取文本左边 (key, 1) ≠ “[”)
        对象名称 ＝ DataName ＋ “.” ＋ key
    .默认
        对象名称 ＝ DataName ＋ key
    .判断结束

.默认
    对象名称 ＝ DataName
.判断结束
.判断开始 (是否为空 (value_对象) ＝ 假)
    Object.数值方法 (“Eval”, 对象名称 ＋ “.unshift(” ＋ value_对象 ＋ “)”)
.判断 (是否为空 (value_文本型) ＝ 假)
    数值处理数组 ＝ 分割文本 (value_文本型, “,”, )
    .计次循环首 (取数组成员数 (数值处理数组), 计数器1)
        .如果 (计数器1 ＝ 1)
            最终数值 ＝ #引号 ＋ 数值处理数组 [计数器1] ＋ #引号
        .否则
            最终数值 ＝ 最终数值 ＋ “,” ＋ #引号 ＋ 数值处理数组 [计数器1] ＋ #引号
        .如果结束

    .计次循环尾 ()
    Object.数值方法 (“Eval”, 对象名称 ＋ “.unshift(” ＋ 最终数值 ＋ “)”)
.判断 (是否为空 (value_数值型) ＝ 假)
    Object.数值方法 (“Eval”, 对象名称 ＋ “.unshift(” ＋ value_数值型 ＋ “)”)
.判断 (是否为空 (value_逻辑型) ＝ 假)
    数值处理数组 ＝ 分割文本 (value_逻辑型, “,”, )
    .计次循环首 (取数组成员数 (数值处理数组), 计数器1)
        .如果 (计数器1 ＝ 1)
            .判断开始 (数值处理数组 [计数器1] ＝ “true” 或 数值处理数组 [计数器1] ＝ “1” 或 数值处理数组 [计数器1] ＝ “真”)
                最终数值 ＝ “true”
            .判断 (数值处理数组 [计数器1] ＝ “false” 或 数值处理数组 [计数器1] ＝ “0” 或 数值处理数组 [计数器1] ＝ “假”)
                最终数值 ＝ “false”
            .默认

            .判断结束

        .否则
            .判断开始 (数值处理数组 [计数器1] ＝ “true” 或 数值处理数组 [计数器1] ＝ “1” 或 数值处理数组 [计数器1] ＝ “真”)
                最终数值 ＝ 最终数值 ＋ “,” ＋ “true”
            .判断 (数值处理数组 [计数器1] ＝ “false” 或 数值处理数组 [计数器1] ＝ “0” 或 数值处理数组 [计数器1] ＝ “假”)
                最终数值 ＝ 最终数值 ＋ “,” ＋ “false”
            .默认

            .判断结束

        .如果结束

    .计次循环尾 ()
    Object.数值方法 (“Eval”, 对象名称 ＋ “.unshift(” ＋ 最终数值 ＋ “)”)
.判断 (是否为空 (value_数组) ＝ 假)
    Object.数值方法 (“Eval”, 对象名称 ＋ “.unshift(” ＋ value_数组 ＋ “)”)
.默认

.判断结束

返回 (Object.数值方法 (“Eval”, 对象名称 ＋ “.length”))

.子程序 数组_剪接成员, 文本型, 公开, 删除并返回数组的指定位置元素，如果数组已经是空值，则返回一个空值。
.参数 key, 文本型, 可空, 支持“a.b.c”或“a[0].b”等模式混合，如果留空或者为空文本表示根键。
.参数 index, 整数型, , 要删除元素在数组中的位置，从0开始。
.参数 howmany, 整数型, 可空, 要删除的元素数目，为空则删除1个，为0将不删除。
.局部变量 对象名称, 文本型

.判断开始 (取文本长度 (key) ＞ 0)
    .判断开始 (取文本左边 (key, 1) ≠ “[”)
        对象名称 ＝ DataName ＋ “.” ＋ key
    .默认
        对象名称 ＝ DataName ＋ key
    .判断结束

.默认
    对象名称 ＝ DataName
.判断结束
.如果真 (是否为空 (howmany))
    howmany ＝ 1
.如果真结束
返回 (Object.文本方法 (“Eval”, “JSON.stringify(” ＋ 对象名称 ＋ “.splice(” ＋ 到文本 (index) ＋ “,” ＋ 到文本 (howmany) ＋ “)” ＋ “)”))

